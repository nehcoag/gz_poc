<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<div class="mainCvshd" id="mainCvshd" style="width: 1300px;height: 700px;"></div>
<script src="../js/Three.js"></script>
<script src="../js/Tween.js"></script>
<script src="../js/MTLLoader.js"></script>
<script src="../js/OBJLoader.js"></script>
<script src="../js/OrbitControls.js"></script>
<script src="../models/ChinaCustoms.js"></script>
<script>
    initTwModel("mainCvshd");

    function initTwModel(dom) {
        var dom_intersected, dom_oriColor;
        var WIDTH = document.getElementById(dom).offsetWidth;
        var HEIGHT = document.getElementById(dom).offsetHeight;
        //默认参数设置
        // var layerNum = 5;//层数
        // var layerHeight = 45;//层高
        // var layerGaps = 5;//间隔
        // var areaNum = 4;//面数
        var VIEW_ANGLE = 20,//25
            ASPECT = WIDTH / HEIGHT,
            NEAR = 50000,
            FAR = 60000;
        /* 初始化3D面板 */
        var scene = new THREE.Scene();
        var renderer = new THREE.WebGLRenderer({alpha: true, antialias: true});
        renderer.shadowMapType = THREE.PCFSoftShadowMap;
        renderer.setSize(WIDTH, HEIGHT);
        renderer.shadowMapEnabled = true;//允许阴影映射，渲染阴影需要大量的资源，因此我们需要告诉渲染器我们需要阴影
        document.getElementById(dom).appendChild(renderer.domElement);

        //生成一个坐标轴，辅助线
        var axes=new THREE.AxisHelper(20000);
        scene.add(axes);
        //生成一个平面
        var planeGeometry=new THREE.PlaneGeometry(20000,20000);//平面
        //生成一个材质
        var planeMaterial=new THREE.MeshLambertMaterial({color:0xffffff});
        //生成一个网格，将平面和材质放在一个网格中，组合在一起，组成一个物体
        var plane=new THREE.Mesh(planeGeometry,planeMaterial);
        plane.rotation.x=-0.5*Math.PI;//将平面沿着x轴进行旋转
        plane.position.x=0;
        plane.position.y=-8000;
        plane.position.z=0;
        plane.receiveShadow=true;//平面进行接受阴影
        scene.add(plane);
        /* 灯光 */
        var ambientLight = new THREE.AmbientLight("#ffffff");
        scene.add(ambientLight);
        //生成半球光源
        var hemiLight=new THREE.HemisphereLight(0xBDB76B,0x7F7F7F,0.6);
        hemiLight.position.set(0,500,0);
        hemiLight.groundColor = new THREE.Color(0x00ff00);//设置地面发出的光线的颜色
        hemiLight.color = new THREE.Color(0x0000ff);//设置天空发出的光线的颜色
        hemiLight.intensity = 0.6;
        // scene.add(hemiLight);

        //生成聚光灯
        var spotLight0 = new THREE.PointLight(0xBDB76B);
        spotLight0.position.set(-3000,-2000,3500);
        spotLight0.lookAt(plane);
        // scene.add(spotLight0);
        // var spotLight1 = new THREE.PointLight(0xBDB76B);
        // spotLight1.position.set(3000,2000,-3500);
        // spotLight1.lookAt(plane);
        // scene.add(spotLight1);

        //生成一个方向光，模拟太阳光
        var pointColor = "#BDB76B";
        var dirLight = new THREE.DirectionalLight(pointColor);
        dirLight.position.set(-100, -80, 10);
        // dirLight.castShadow = true;
        // dirLight.target = plane;
        // dirLight.shadowCameraNear = 0.1;
        // dirLight.shadowCameraFar = 200;
        // dirLight.shadowCameraLeft = -50;
        // dirLight.shadowCameraRight = 50;
        // dirLight.shadowCameraTop = 50;
        // dirLight.shadowCameraBottom = -50;
        // dirLight.shadowMapWidth = 2048;
        // dirLight.shadowMapHeight = 2048;
        // scene.add(dirLight);
        /*相机*/
        var camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
        camera.position.set(0, 100, 50000);
        // camera.rotation.x = -0.2;//-0.2
        scene.add(camera);
        var onProgress = function (xhr) {
            if (xhr.lengthComputable) {
                var percentComplete = xhr.loaded / xhr.total * 100;
                console.log(Math.round(percentComplete, 2) + '% downloaded');
            }
        };

        var onError = function (xhr) {
        };
        // var mtlLoader = new THREE.MTLLoader();
        // mtlLoader.setPath('../models/');
        // mtlLoader.load('ChinaCustoms.mtl', function (materials) {
        //     materials.preload();
            var objLoader = new THREE.OBJLoader();
            // objLoader.setMaterials(materials);
            objLoader.setPath('../models/');
            objLoader.load('ChinaCustoms.obj', function (object) {
                var objArr=object.children;
                console.log(objArr);
                // var edges=[];
                for(var i=0;i<objArr.length;i++){
                    objArr[i].material.side = THREE.FrontSide;
                    objArr[i].material.transparent=true;
                    // objArr[i].material.opacity=0.5;
                    objArr[i].material.color.set("#faeede");
                    /*白色网格*/
                    // var edge = new THREE.EdgesHelper(objArr[i], 0x8cc4f0);
                    // console.log(edge);
                    // edge.material.linewidth = 1;
                    // edge.position.y = -6000;
                    // scene.add(edge);
                    // edges.push(edge);//将单个网格PUSH到白色网格数组
                    var edges = new THREE.EdgesGeometry(objArr[i].geometry);
                    var line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( { color: 0x856F61,linewidth:1,opacity:1 } ) );
                    objArr[i].add( line );
                }
                // edges.position.y = -6000;
                object.position.y = -6000;
                scene.add(object);
                // myCameraTweenByAnyAxis(camera, 300, 1, 1000);

                /*动画转圈效果*/
                function render() {
                    object.rotation.y += 0.005;
                    requestAnimationFrame( render );
                    renderer.render( scene, camera );
                }
                render();
            }, onProgress, onError);

        // });

        /*鼠标控制*/
        var controls = new THREE.OrbitControls(camera);
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = 6.28;
        controls.minDistance = 10000;
        controls.maxDistance = 100000000;
        // camera.position.set( 0, 500, 1000 );
        controls.addEventListener('change', render);

        /*渲染*/
        function render() {
            renderer.render(scene, camera);
        }


        // renderer.domElement.addEventListener("mousemove", mousemove);
        // renderer.domElement.addEventListener("mouseover", mouseover);
        // renderer.domElement.addEventListener("mouseout", mouseout);
        // renderer.domElement.addEventListener("mousedown", mousedown);
        //光线投射器
        var raycaster = new THREE.RayCaster();
        var mouse = new THREE.Vector2();
        function mousedown(event) {
            // console.log(renderer.domElement.getBoundingClientRect().x);
            mouse.x = ( (event.clientX-renderer.domElement.getBoundingClientRect().left) / renderer.domElement.clientWidth ) * 2 - 1;
            mouse.y = - ( (event.clientY-renderer.domElement.getBoundingClientRect().top) / renderer.domElement.clientHeight ) * 2 + 1;
            // console.log(mouse);
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(scene.children[29].children);
            console.log(scene.children[29].children);
            // console.log(intersects);
            if (intersects.length) {
                var ndom_intersected = intersects[0].object.name;
                console.log(ndom_intersected);
                intersects[0].object.material.color.set("#f00");
            }
        }
        /*function mousemove(e) {
            mouse.x = (e.clientX - 12) / renderer.domElement.clientWidth * 2 - 1;
            mouse.y = -((e.clientY - 12) / renderer.domElement.clientHeight * 2) + 1;
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(scene.children);
            var ndom_intersected, ndom_oriColor;
            if (intersects.length) {
                ndom_intersected = intersects[0].object;
                ndom_oriColor = ndom_intersected.material.color.getHex();
                ndom_intersected.material.color.set(0xffff00);
                /!*移入鼠标后放大效果*!/
                if (dom_intersected != ndom_intersected) {
                    if (dom_intersected) dom_intersected.material.color.set(dom_oriColor);
                    dom_intersected = ndom_intersected;
                    dom_oriColor = ndom_oriColor;
                }
            } else {
                if (dom_intersected) {
                    dom_intersected.material.color.set(dom_oriColor);
                    dom_intersected = null;
                }
            }
        }

        function mousedown(e) {
            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length) {
                var ndom_intersected = intersects[0].object;
                console.log(ndom_intersected)
                if (ndom_intersected.id == 12) {
                    console.log("1")
                } else if (ndom_intersected.id == 14) {
                    console.log("2")
                }
            }
        }*/

        // function mouseover(e) {
        //     window.isHover = true;
        //     loopShadow(cbarr, [0, 1, 2, 3, 4]);
        // }

        // function mouseout(e) {
        //     window.isHover = false;
        // }


    };

    /*
         *camera:相机
         *angle：旋转角度
         *segs:分段，即圆弧对应的路径分为几段
         *during：动画执行的时间
        */
    function myCameraTweenByAnyAxis(camera, angle, segs, during) {

        var x = camera.position.x;
        var y = camera.position.y;
        var z = camera.position.z;

        //相机向量（指向场景中心）
        var v1 = new THREE.Vector3(x, y, z);

        //求旋转轴，v1的垂直单位向量,令x=1,y=1,z=-(v1.x+v1.y)/v1.z
        var n = (new THREE.Vector3(1, 0, -1.0 * v1.x / v1.z)).normalize();

        var endPosArray = new Array();

        var perAngle = angle / segs;

        for (var i = 1 ; i <= segs ; i++) {
            var sinDelta = Math.sin(THREE.Math.degToRad(i * perAngle));
            var cosDelta = Math.cos(THREE.Math.degToRad(i * perAngle));

            var tempX = x * (n.x * n.x * (1 - cosDelta) + cosDelta) + y * (n.x * n.y * (1 - cosDelta) - n.z * sinDelta) + z * (n.x * n.z * (1 - cosDelta) + n.y * sinDelta);
            var tempY = x * (n.x * n.y * (1 - cosDelta) + n.z * sinDelta) + y * (n.y * n.y * (1 - cosDelta) + cosDelta) + z * (n.y * n.z * (1 - cosDelta) - n.x * sinDelta);
            var tempZ = x * (n.x * n.z * (1 - cosDelta) - n.y * sinDelta) + y * (n.y * n.z * (1 - cosDelta) + n.x * sinDelta) + z * (n.z * n.z * (1 - cosDelta) + cosDelta);

            var endPos = { "x": tempX, "y": tempY, "z": tempZ };

            //console.log(endPos);
            endPosArray.push(endPos);
        }

        var flag = 0;
        var id = setInterval(function () {
            if (flag == segs) {
                clearInterval(id);
            } else {
                camera.position.x = endPosArray[flag].x;
                camera.position.y = endPosArray[flag].y;
                camera.position.z = endPosArray[flag].z;

                camera.updateMatrix();

                flag++;
            }
        }, during / segs);
    }
</script>
</body>
</html>